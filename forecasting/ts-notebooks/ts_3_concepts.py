# -*- coding: utf-8 -*-
"""ts-3-concepts.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kGbMyhiTsyhLkU5N7HFsSK3j8sufW42W

# Time series Concepts and modelling

In this notebook, we shall study and experiment with the statistical tools used for time series data. We will begin with examining characteristics of a time series followed by modelling it. As an example, we take "node_memory_Active_bytes" which are the memory bytes that have been recently used by a node. It reflects the memory pressure on the node.
This notebook can be used as a guideline to analyze, understand, and model any time series data. 

## Contents

- Load data
- Concepts
    - Standard time series
      - White noise
      - Random walk
    - Stationarity 
      - Dicky Fuller Test
    - Seasonality
      - Naive decomposition - Additive 
      - Multiplicative
      - Synthetic seasonal data
    - Auto Correlation
      - ACF
      - PACF
- Modelling
    - Manual
        - Linear Regression
        - Exponential Smoothing
        - AR
        - MA
        - ARMA
        - ARIMA
        - SARIMAX
    - Automatic 
        - Auto ARIMA

## Load Data
"""

from prometheus_api_client import PrometheusConnect  # noqa: F401
from prometheus_api_client.metric_range_df import (  # noqa: F401
    MetricRangeDataFrame,
)
from datetime import timedelta, datetime  # noqa: F401
import pandas as pd
from sklearn import linear_model
from statsmodels.tsa.api import SimpleExpSmoothing, Holt
from statsmodels.tsa.stattools import adfuller
from statsmodels.tsa.seasonal import seasonal_decompose
import statsmodels.graphics.tsaplots as sgt
from statsmodels.tsa.arima_model import ARMA
from statsmodels.tsa.arima_model import ARIMA
from statsmodels.tsa.statespace.sarimax import SARIMAX
from pmdarima import auto_arima
from scipy.stats.distributions import chi2
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import itertools
import warnings
# from fbprophet import Prophet


warnings.filterwarnings("ignore")

# # To ensure reproducibilty, use the saved snapshot of time series data.
# # For modelling on your own as an exercise, fetch new data using this cell.

# # Creating the prometheus connect object with the required parameter
# prom_url = "http://demo.robustperception.io:9090"
# pc = PrometheusConnect(url=prom_url, disable_ssl=True)

# Request fixed data for 1 week
# start_time = datetime(2021, 2, 2)
# end_time = datetime(2021, 2, 9)
# metric_data = pc.get_metric_range_data(
#     "node_memory_Active_bytes",  # metric name and label config
#     start_time=start_time,  # datetime object for metric range start time
#     end_time=end_time,
#     chunk_size=timedelta(
#         days=1
#     ),  # timedelta object for duration of metric data downloaded in one request
# )

# ## Make the dataframe
# metric_df = MetricRangeDataFrame(metric_data)
# metric_df.index = pd.to_datetime(metric_df.index, unit="s", utc=True)
# ## Save the sanpshot of the data to ensure reproducibility
# metric_df.to_pickle("../data/raw/ts.pkl")

metric_df = pd.read_pickle("ts.pkl")
ts = metric_df["value"].astype(float).resample("min").mean()
sns.set()
ts.plot(figsize=(15, 10))
plt.title("Visualize time series")
plt.ylabel("Node memory active bytes")
plt.show()

# """## Concepts
#
# ### Standard time series
# Before defining statistical properties, let's understand two standard time series: white noise and random walk. These time series are often used to understand and compare others.
#
# #### [White noise](https://en.wikipedia.org/wiki/White_noise)
# - White noise has constant mean, constant variance, and no autocorrelation (no relationship between past and present of time series)
# """
#
# ## Create a wn time series with mean, std, length same as our loaded data
# wn = np.random.normal(loc=ts.mean(), scale=ts.std(), size=len(ts))
# pd.DataFrame(wn).plot(figsize=(15, 10))
# plt.title("Visualize white noise")
# plt.ylabel("value")
# plt.xlabel("time")
# plt.show()
#
# """#### [Random walk](https://towardsdatascience.com/random-walks-with-python-8420981bc4bc)
# - A random walk is modelled using this equation: P<sub>t</sub> = P<sub>t-1</sub> + $\epsilon$<sub>t</sub> where $\epsilon$<sub>t</sub> is white noise.
# - Random walks are not predictable
# """
#
# ## Randomly choose from -1, 0, 1 for the next step
# random_steps = np.random.choice(a=[-1, 0, 1], size=(len(ts), 1))
# rw = np.concatenate([np.zeros((1, 1)), random_steps]).cumsum(0)
# pd.DataFrame(rw).plot(figsize=(15, 10))
# plt.title("Visualize random walk")
# plt.ylabel("value")
# plt.xlabel("time")
# plt.show()
#
# """### [Stationarity](https://towardsdatascience.com/stationarity-in-time-series-analysis-90c94f27322)
#
# Intuitively, a stationary time series does not change the way it changes. In other words, the statistical properties of the process generating the time series does not change over time. For real world problems, we use the weak form or covariance stationarity definition:
# - Constant $\mu$
# - Constant $\sigma$
# - Cov (x<sub>n</sub>, x<sub>n+k</sub>) = Cov (x<sub>m</sub>, x<sub>m+k</sub>)
#
# Ideally we would want the time series to be stationary for modelling. In the real world it is rarely stationary. We shall now look at the Dickey Fuller Test which determines if a series is stationary or not.
#
# ## Dickey Fuller Test
# - This test determines if the time series is stationary or not.
# - If p value > 0.05 then process is not stationary.
# - If p < 0.05, null hypothesis is rejected and the process is stationary.
# """
#
# dft = adfuller(ts)
# print(
#     f"p value {round(dft[1], 4)}",
#     f"\n Test statistic {round(dft[0], 4)}",
#     f"\n Critical values {dft[4]}",
# )
#
# """For this series, the p-value is 0 which means that the null hypothesis can be rejected and the series is stationary. The test statistic of -15.6815 is less than 1% critical value (-3.4304) meaning that the chances of this result being a fluke is less than 1%. """
#
# ## Examining white noise
# dft = adfuller(wn)
# print(
#     f"p value {round(dft[1], 4)}",
#     f"\n Test statistic {round(dft[0], 4)}",
#     f"\n Critical values {dft[4]}",
# )
#
## Examining random walk
# dft = adfuller(rw.squeeze())
# print(
#     f"p value {round(dft[1], 4)}",
#     f"\n Test statistic {round(dft[0], 4)}",
#     f"\n Critical values {dft[4]}",
# )
#
# """As we can see from the above, we know by definition that that white noise is stationary and the random walk is not. Since the results of the Dickey Fuller test verified our expected results, we know that we can at least have some confidence in this statistical test when it indicates to us that our real world time series data set is stationary.
#
# ### Seasonality
# - There are certain trends in some time series that appear cyclically.
# - We can decompose the time series data into trend, seasonal, residual
# - Trend: general pattern present in the time series
# - Seasonal: cyclical effect in the time series
# - Residual: Error of prediction
#
# #### Naive Decomposition
# One way to decompose a time series in order to check for seasonality is through naive decomposition that assumes an additive or multiplicative nature between the three components: trend, seasonal, residual.
#
# Additive
# - Observed = trend + seasonal + residual
#
# Multiplicative
# - Observed = trend * seasonal * residual
# """
#
# # Since this is minutely data, we have set freq=60*24 implying that we need to focus on one day
# # We need to manually gauge this parameter in order to come up with the right decomposition
# # We can set it to 60 to focus on hourly decomposition as well
# plt.rc("figure", figsize=(15, 10))
# sd_add = seasonal_decompose(ts, model="additive", freq=60 * 24)
# sd_add.plot()  # Image manipulation doesn't work here.
# plt.show()
#
# # Since this is minutely data, we have set freq=60*24 implying that we need to focus on one day
# # We need to manually gauge this parameter in order to come up with the right decomposition
# # We have can it to 60 to focus on hourly decomposition as well
# plt.rc("figure", figsize=(15, 10))
# sd_add = seasonal_decompose(ts, model="multiplicative", freq=60 * 24)
# sd_add.plot()  # Image manipulation doesn't work here.
# plt.show()
#
# """Both additive and multiplicative models give a similar output. There is a downward trend in memory usage at the begining of the week and it remains low throughout the week increasing slightly towards the end. The seasonal values show an oscillating behavior, however we can see that within a day, it starts high and reduces towards the end. The residuals however do not seem exactly random (like white noise) indicating that the decomposition is not perfect.
# For a better understanding, let's try these methods on a synthetic seasonal time series.
# """
#
# time = np.arange(50)
# ## Create a pattern
# values = np.where(time < 10, time ** 3, (time - 9) ** 2)
# ## Repeat it several times
# seasonal = np.hstack((values, values, values, values, values))
# ## Add noise
# noise = np.random.randn(250) * 100
# ## Add upward trend
# trend = np.arange(250) * 10
# ## Combine all
# synthetic_time_series = seasonal + noise + trend
# ## Visualize
# pd.DataFrame(synthetic_time_series).plot()
# plt.xlabel("time")
# plt.ylabel("value")
# plt.title("Synthetic seasonal time series")
# plt.show()
#
# # For this data, we set freq=50 since we repeated a pattern 50 times
# # Again, we used additional information to gauge this parameter
# sd_add = seasonal_decompose(synthetic_time_series, model="additive", freq=50)
# sd_add.plot()  # Image manipulation doesn't work here.
# plt.rc("figure", figsize=(15, 10))
# plt.show()
#
# """No surprises here, but we see that the time series being perfectly decomposed into the trend and the seasonal variations. The residuals look like white noise as well. We can use such decomposition for simpifying and understanding all time series data.
#
# ### Auto-correlation
# Auto correlation refers to correlation of a time series with a lagged version of itself.
#
# #### [ACF](https://towardsdatascience.com/significance-of-acf-and-pacf-plots-in-time-series-analysis-2fa11a5d10a8)
# Auto correlation function for how the number of lags we are interested in.
# """
#
# sgt.plot_acf(ts, lags=50, zero=False)
# ## We give zero=False since correlation of a time series with itself is always 1
# plt.rc("figure", figsize=(15, 10))
# plt.ylabel("Coefficient of correlation")
# plt.xlabel("Lags")
# plt.show()
#
# """- X axis represents the number of lags.
# - Y axis represents the correlation value of the time series with a lagged version of itself
# - Blue area depicts significance. In this plot, all lines are higher than significance which means that all the autocorrelation coefficients are significant.
# - Interpretation: There is time dependence in the data since we see high correlation. In other words, we can even use 50 points behind to predict what comes next.
# - This curve is also indicative of some non-stationarity in the dataset. Although the dickey-fuller test shows stationarity, ACF plot with many significant coefficients may require integrations before modelling (explained in ARIMA section).
# """
#
# ## Let's examine auto correlation of white noise
# sgt.plot_acf(wn, lags=50, zero=False)
# plt.rc("figure", figsize=(15, 10))
# plt.ylabel("Coefficient of correlation")
# plt.xlabel("Lags")
# plt.show()
#
# """- We see that most coefficients are not significant
# - Randomly, some of them cross the blue area
# - Hence, white noise has no auto correlation or no time dependence
#
# #### PACF (Partial Auto correlation)
# - Accounts for direct effect of x<sub>lagged</sub> on x<sub>t</sub>
# - For example, ACF for a lag of 3, will also include effect of x<sub>t-3</sub> on x<sub>t-2</sub>, x<sub>t-2</sub> on x<sub>t-1</sub>, and x<sub>t-1</sub> on x<sub>t</sub>
# - PACF for a lag of 3, only accounts for effect of x<sub>t-3</sub> on x<sub>t</sub>
# - The first value is same for both as there are no indirect influences in the first computation.
# """
#
# sgt.plot_pacf(ts, zero=False, method="ols")
# plt.rc("figure", figsize=(15, 10))
# plt.ylabel("Coefficient of correlation")
# plt.xlabel("Lags")
# plt.show()
#
# """Great! now we have a basic understanding of statistical properties of the time series data. Next, we'll look at how to model a time series data.
#
# ## Modelling
#
# Before we dive into various time series models, here are some general points to keep in mind:
# - Start with a simple parsimonious model and add more parameters and complexity as required.
# - If coefficients of added variables are significantly different from zero keep them otherwise prefer simpler models to favour generalizability.
# - To see if we should select the more complex model, we can compare log likelihood, information criterion like AIC, and BIC.
# - Residuals: If the model fits the data well then the residuals should resemble white noise (or in other words, there is no trend left to capture).
#
# ### Linear Regression Model
#
# Linear regression is a linear model, a model that assumes a linear relationship between the input variables (x) and the single output variable (y). y can be calculated from a linear combination of the input variables (x). If we try to draw a relatonshop between these two variables, we get a straight line that can be mathematically expressed as :
#
#
#
# * y = mx + b
#
# Where b is the intercept and m is the slope of the line.
#
#
#
# * y<sub>t</sub> = β<sub>0</sub> + β<sub>1</sub>x<sub>t</sub> + ε<sub>t</sub>
#
#
# The coefficients β<sub>0</sub> and β<sub>1</sub> denote the intercept and the slope of the line respectively. The intercept β<sub>0</sub> represents the predicted value of y when x=0. The slope β<sub>1</sub> represents the average predicted change in y resulting from a one unit increase in x.
#
#  So basically, the linear regression algorithm gives us the most optimal value for the intercept and the slope in a two dimensional environment.  The x and y values
# """
#
# train = ts[0 : int(len(ts) * 0.8)]
# test = ts[int(len(ts) * 0.8) :]
# train_time = [i + 1 for i in range(len(train))]
# test_time = [i + 8065 for i in range(len(test))]
#
# LinearRegression_train = pd.DataFrame(train)
# LinearRegression_test = pd.DataFrame(test)
# LinearRegression_train["time"] = train_time
# LinearRegression_test["time"] = test_time
#
# LinearRegression_train.tail()
#
# LinearRegression_test.head()
#
# plt.figure(figsize=(16, 5))
# plt.plot(LinearRegression_train["value"], label="Train")
# plt.plot(LinearRegression_test["value"], label="Test")
# plt.legend(loc="best")
# plt.xlabel("Time")
# plt.ylabel("Value")
# plt.xticks(rotation=90)
# plt.show()
#
# # Training the algorithm
# lr = linear_model.LinearRegression()
# lr.fit(
#     LinearRegression_train[["time"]], LinearRegression_train["value"].values
# )
#
# """As discussed previously, we saw that Linear Regression model looks for the best value for the intercept and result in a line that best fits the data. Let's see how we can retrieve those parameters."""
#
# # Intercept
# print("Intercept :", lr.intercept_)
# # Coeffiecient of x : Slope
# print("Coefficient of x :", lr.coef_)
#
# """This means that for every one unit of change in time, the change in the value is about `-4126.27`. However, this information doesn't help a lot in knowing how the time series data would change with time. This method can be mostly be useful in cases where the data is linear. In this scenario we have some trends and seasonality as well. We will now move towards Exponential Smoothing models to see how they are different and better than linear models.
#
# ### Exponential Smoothing Model
# Forecasts produced using exponential smoothing methods are weighted averages of past observations, with the weights decaying exponentially as the observations get older. In other words, the more recent the observation the higher the associated weight.
#
# #### Simple Exponential Smoothing
# Simple exponential smoothing method is most suitable for forecasting data with no clear trend or seasonal pattern. It requires a single parameter, called alpha (α), also called the smoothing factor or smoothing coefficient.
#
# * Alpha (*smoothing_level*) controls the rate at which the influence of the observations at prior time steps decay exponentially.
# * Alpha is often set to a value between 0 and 1.
# * Large values mean that the model pays attention mainly to the most recent past observations, whereas smaller values mean more of the history is taken into account when making a prediction.
#
#
# * As we mentioned, that SES has only one component, let's see how it is represented in mathematical form :
#
#     * Forecast : p<sub>t</sub> = l<sub>t
#
#     * Level : l<sub>t = α y<sub>t</sub>  +  (1-α)l<sub>t-1
#
#   Where p is the forecast, l is the level and α is the smoothing factor.
# """
#
# ses_train = pd.DataFrame(train)
#
# # Try autofit
# ses_model = SimpleExpSmoothing(ses_train["value"])
# ses_model_autofit = ses_model.fit(optimized=True, use_brute=True)
# ses_model_autofit.summary()
#
# """The above model is a result of the autofit model by statsmodels. As mentioned above, the depends on one parameter alpha also known as the smoothing factor or smoothing coefficient. According to autofit, the best alpha for this data would be `0.995`. That means the model pays attention mainly to the most recent past observations.
#
# **Optimize Alpha**
#
# We could also try other values for alpha as follows and will chose the minimum AIC i.e. Akaike’s Information Criterion which is defined as :
#
# `AIC = -2log(L) + 2k`
#
# where L is the likelihood of the model and k is the total number of parameters and initial states that have been estimated (including the residual variance).
#
# The measures on the training set (training sample) are not really suitable as basis for model selection. It is because in the training sample it is always possible to overfit, and the richer the model, the better the fit will be. Meanwhile, information criteria like AIC or BIC take this into account and penalize for the model complexity accordingly. Therefore, they generally are suitable for model selection. For this model let's try to minimize the value of AIC in order to find the best model.
# """
#
# # Try to optimize the coefficient by finding minimum AIC.
# min_ses_aic = 99999999
# for i in np.arange(0.01, 1, 0.01):
#     ses_model_alpha = ses_model.fit(
#         smoothing_level=i, optimized=False, use_brute=False
#     )
#     # You can print to see all the AIC values
#     # print(' SES {} - AIC {} '.format(i,ses_model_alpha.aic))
#     if ses_model_alpha.aic < min_ses_aic:
#         min_ses_aic = ses_model_alpha.aic
#         min_aic_ses_model = ses_model_alpha
#         min_aic_alpha_ses = i
#
# print("Best Alpha : ", min_aic_alpha_ses)
# print("Best Model : \n")
# min_aic_ses_model.summary()
#
# """The above implementation of Simple Exponential Smoothing allows us to compare the autofit and manual grid search for best alpha and best model. Both the alphas are pretty comparable and gives us the best model. However, this model performs better where there is no seasonality and trend. So we will move to Holt's model that covers the `trend` in data but no seasonality.
#
# #### Holt's Double Exponential Smoothing Model
# Holt's Double Exponential Smoothing method is similar to Simple Exponential Smoothing. It calculates the level component to measure the level in the Forecast.In addition to the alpha parameter for controlling smoothing factor for the level, an additional smoothing factor is added to control the decay of the influence of the change in trend called beta (β).
#
# * Forecast Equation : p<sub>t+h|t</sub> = l<sub>t</sub> + hb<sub>t</sub>
# * Level Equation : l<sub>t</sub> = αy<sub>t</sub> + (1-α)l<sub>t-1</sub>
# * Trend Equation : b<sub>t</sub> = β(l<sub>t</sub> - l<sub>t-1</sub>) + (1-β)b<sub>t-1</sub>
#
#   Where p is the forecast, l is the level, α is the smoothing factor and β is the smoothing slope.
# """
#
# # since optimization is intensive, we are sampling for this method
# ts_holt = metric_df["value"].astype(float).resample("30min").mean()
# train = ts_holt[0 : int(len(ts_holt) * 0.8)]
# test = ts_holt[int(len(ts_holt) * 0.8) :]
# des_train = pd.DataFrame(train)
#
# # Try out autofit model and see what alpha and beta values are.
# des_model = Holt(des_train["value"])
# des_model_autofit = des_model.fit(optimized=True, use_brute=True)
# des_model_autofit.summary()
#
# """Just like we did for Simple Exponential Smoothing model, for this model also let's try to minimize the value of AIC in order to find the best model. The only difference here would be that we have two parameters : alpha and beta."""
#
# # Try to optimize the coefficient:
# min_des_aic = 99999
# for i in np.arange(0.01, 1, 0.01):
#     for j in np.arange(0.01, 1.01, 0.01):
#         des_model_alpha_beta = des_model.fit(
#             smoothing_level=i,
#             smoothing_slope=j,
#             optimized=False,
#             use_brute=False,
#         )
#         # You can print to see all the AIC values
#         # print(' DES {} - AIC {} '.format(i,des_model_alpha_beta.aic))
#         if des_model_alpha_beta.aic < min_des_aic:
#             min_des_aic = des_model_alpha_beta.aic
#             min_aic_des_model = des_model_alpha_beta
#             min_aic_alpha_des = i
#             min_aic_beta_des = j
#
# print("Best Alpha : ", min_aic_alpha_des)
# print("Best Beta : ", min_aic_beta_des)
# print("Best Model : \n")
# min_aic_des_model.summary()
#
# """The above implementation of Simple Exponential Smoothing allows us to compare the autofit and manual grid search for best alpha, beta and best model. Both the alphas and betas are very different from each other. However, this model performs better where there is no seasonality. So we will move to other approaches that capture seasonality as well.
#
# ### Auto regressive (AR) Model
# The next model we will explore is the AR model. Linear regression models the linear relationship of predictors whereas ARIMA models the linear relationship of past observation. This makes ARIMA naturally adaptive to new data [source]. The following equation shows AR(1) or auto regression model that learns from just one past observation.
#
# x<sub>t</sub> = c + $\phi$x<sub>t-1</sub> + $\epsilon$<sub>t</sub>
#
#
# - $\phi$ is a numerical constant from -1 to 1 (otherwise it'll blow up)
#
# - $\epsilon$<sub>t</sub> represents unpredictable shocks.
#
# In real life, looking at just 1 lag may not give reasonable results. To determine the optimal number of lags, we look at PACF plots and incrementally increase the number.
# If we have coefficients close to 1, that means they can be good candidates for the model.
# Note: AR model stationary process better. For non-stationary time series, it is often converted to stationary process first.
# """
#
# sgt.plot_pacf(ts, zero=False, method="ols")
# plt.rc("figure", figsize=(15, 10))
# plt.ylabel("Coefficient of correlation")
# plt.xlabel("Lags")
# plt.show()
#
# ## Let's start with a simple model with 1 lag
# ## Since we have the highest PACF coefficient for lag 1
# model_ar_1 = ARMA(ts, order=(1, 0))
# results_ar_1 = model_ar_1.fit()
#
# results_ar_1.summary()
#
# """Interpretation:
# - ar.L1.value is the value of $\phi$ in the AR(1) equation.
# - const is the value of c in AR(1) equation.
# - p < 0.05 suggests that these coefficients are significant.
# - Since the ar.L1.value is not 0, this variable adds to the model.
# - Great! let's increase the order and see if the more complex model is better.
# """
#
# model_ar_2 = ARMA(ts, order=(2, 0))
# results_ar_2 = model_ar_2.fit()
#
# results_ar_2.summary()
#
# """Alright, we have a more complex model, but is it adding anything new?
# The log likelihood ratio (LLR) test determines if the new model adds value to the modelling significantly. It returns a p value, if p<0.05 then the complex model is better.
# """
#
# # LLR Test
# def llr_test(res_1, res_2, df=1):
#     l1, l2 = res_1.llf, res_2.llf
#     lr = 2 * (l2 - l1)
#     p = chi2.sf(lr, df).round(3)
#     result = "Insignificant"
#     if p < 0.005:
#         result = "Significant"
#     return p, result
#
#
# llr_test(results_ar_1, results_ar_2)
#
# """So the second model is significantly better than the first."""
#
# ## Let's automate this process to find the order
# llr = 0
# p = 1
# results = ARMA(ts, order=(p, 0)).fit()
# while llr < 0.05:
#     results_prev = results
#     p += 1
#     results = ARMA(ts, order=(p, 0)).fit()
#     llr, _ = llr_test(results_prev, results)
#     print(p, llr)
#
# """The above code suggests that going from order 3 to order 4 does not add any significant value in the model. We can also see that by looking at the summaries of the results.
# Side note: These are rules of thumb but as we see in the pacf plot, some higher lags than 3 are also significant, it could be that a higher lag model may fit the series better.
# """
#
# model_ar_3 = ARMA(ts, order=(3, 0))
# results_ar_3 = model_ar_3.fit()
#
# model_ar_4 = ARMA(ts, order=(4, 0))
# results_ar_4 = model_ar_4.fit()
#
# results_ar_3.summary()
#
# results_ar_4.summary()
#
# """At the end the more complex model should have both insignificant $\phi$ values and insignificant log value. When we reach that stage, in this case at the lag 3, we stop.
#
# Side note: If you want to compare different time series, make sure to normalize values. One way to do this is to divide the series by the first number.
#
# #### Analyzing the residuals
# - This is a very important step in analysing the model performance.
# - Remember that residuals should be similar to white noise reflecting that there is no trend remaining to be captured.
# - We will now plot the residuals, check for stationarity, and check ACF plots.
# """
#
# resid = results_ar_3.resid
#
# resid.plot()
# plt.ylabel("Residuals")
# plt.rc("figure", figsize=(15, 10))
# plt.title("Visualizing residuals")
# plt.show()
#
# print(resid.mean(), resid.var())
#
# adfuller(resid)
#
# sgt.plot_acf(resid, zero=False)
# plt.rc("figure", figsize=(15, 10))
# plt.ylabel("Coefficient of correlation")
# plt.xlabel("Lags")
# plt.show()
#
# """#### Interpretation
# - The plot shows that the residuals look random but are not exactly like white noise.
# - The Dickey Fuller test suggests that the residuals are stationary.
# - The ACF plots show coefficients that are significant further indicating that the residuals are not perfectly white noise and there could be better predictors.
#
# ### Moving average model
#
# - Better suited if the data has unexpected shocks
# - Accounts for the past residuals
# - Absorbs shocks (accounts from past errors) and correct
#
# r<sub>t</sub> = c + $\theta$$\epsilon$<sub>t-1</sub> + $\epsilon$<sub>t</sub>
#
#
# - For finding the optimal number of lags for this model, we rely more on ACF than PACF because it learns from residuals, so the direct effect of a past observation on the present day is not relevant.
# - Mathematical fact: If MA coefficients are close to 1 then it is basically an approximation of AR model.
# - Both AR, MA models are bad with non-stationary data.
# """
#
# sgt.plot_acf(ts, zero=False)
# plt.rc("figure", figsize=(15, 10))
# plt.ylabel("Coefficient of correlation")
# plt.xlabel("Lags")
# plt.show()
#
# """Most the coefficients in the lags are significant implying that MA(n+1) will always be better than MA(n). This type of data suggests that some type of a combination of AR and MA is required to correctly model the data. For reference, let's train a MA model of order 1.
#
# #### model_ma_1 = ARMA(ts, order=(0, 1))  ## p, q where p is AR and q is MA param
# model_ma_results_1 = ARMA(ts, order=(0, 1)).fit()
# model_ma_results_1.summary()
#
# The results show that the coefficient is significant.
#
# ## ARMA (AR and MA models together)
#
# - The ARMA model considers both lagged value and lagged errors.
# - Following equation represents ARMA(1,1):
#
# r<sub>t</sub> = c + $\phi$r<sub>t-1</sub> + $\theta$$\epsilon$<sub>t-1</sub> + $\epsilon$<sub>t</sub>
#
# - For ARMA model, we select complex model and move to simpler models.
# - For determining p, q take hint from PACF and ACF respectively.
# - The  coefficients of the complex model should be significantly better than 0 and the either the AIC should be lower or the LLR test should give significant p-values.
# - LLR test only works for nested models (one model should have all the lag terms of the other). While comparing ARMA(1,3) and ARMA(3,1), we have to look at AIC. Lower values of AIC are prefered over higher values.
#
#
# We found 3 lags for AR component and MA can be anything.
# """
#
# p = range(1, 5)
# q = range(1, 5)
# pq = list(itertools.product(p, q))
# for i in range(1, len(pq)):
#     print("Model: {}".format(pq[i]))
#
# results = []
# for order in pq:
#     try:
#         print(order)
#         model_arma_results = ARMA(ts, order=order).fit()
#         results.append([order, model_arma_results.aic])
#     except ValueError as e:
#         print(order, "Error", e)
#         results.append([order, float("inf")])
#
# results.sort(key=lambda x: x[1])
# results
#
# model_arma_43_results = ARMA(ts, order=(4, 3)).fit()
# model_arma_43_results.summary()
#
# model_arma_33_results = ARMA(ts, order=(3, 3)).fit()
# model_arma_33_results.summary()
#
# """ARMA(4,3) and ARMA(3,3) have low AIC, with all significant coefficients. Both of these models are good candidates for fitting the series.
#
# #### Analyzing the residuals
# """
#
# resid_43 = model_arma_43_results.resid
#
# resid_43.plot()
# plt.ylabel("Residuals")
# plt.rc("figure", figsize=(15, 10))
# plt.title("Visualizing residuals")
#
# adfuller(resid_43)
#
# sgt.plot_acf(resid_43, zero=False)
# plt.rc("figure", figsize=(15, 10))
# plt.ylabel("Coefficient of correlation")
# plt.xlabel("Lags")
# plt.show()
#
# """- This plot has are several significant values in the PACF.
# - We can train higher order ARMA models but usually we have to go for ARIMA models.
#
# ### [ARIMA](https://en.wikipedia.org/wiki/Autoregressive_integrated_moving_average) models
# - Auto-regressive integrated moving average model.
# - Since ARMA models do not work well with non-stationary data, we introduce integrations to make the data the stationary.
# - The model builds on the difference between the time periods (integerated values) instead of the values itself.
# - For example, converting prices to returns in stock market data would be similar to 1 degree of integration.
# - Intuitively, modelling returns instead of prices may be better since returns may resemble stationary data.
# - ARIMA has p, d, q hyperparameters.
# - d -> number of degree of changes to ensure stationarity.
# - One way of finding d is to compute delta of the data unitll stationarity is found.
# - ARIMA method uses AIC criteria to compare models with different orders.
# - The following equation represents ARIMA(1,1,1).
# - Start from a simple model and increase orders by looking at residuals.
#
# $\Delta$P<sub>t</sub> = c + $\phi$$\Delta$P<sub>t-1</sub> + $\theta$$\epsilon$<sub>t-1</sub> + $\epsilon$<sub>t</sub>
# """
#
# arima_111 = ARIMA(ts, order=(1, 1, 1)).fit()
#
# sgt.plot_acf(arima_111.resid, zero=False)
# plt.rc("figure", figsize=(15, 10))
# plt.ylabel("Coefficient of correlation")
# plt.xlabel("Lags")
# plt.show()
#
# """We see that the third lag is significant. We can try all models from ARIMA(0,0,0) to ARIMA(3,1,3)."""
#
# p = range(0, 4)
# d = range(0, 2)
# q = range(0, 4)
# pdq = list(itertools.product(p, d, q))
# for i in range(1, len(pdq)):
#     print("Model: {}".format(pdq[i]))
#
# results = []
# for order in pdq:
#     try:
#         print(order)
#         model_arima_results = ARIMA(ts, order=order).fit()
#         results.append([order, model_arima_results.aic])
#     except ValueError as e:
#         print(order, "Error", e)
#         results.append([order, float("inf")])
#
# results.sort(key=lambda x: x[1])
# results
#
# ARIMA(ts, order=(3, 0, 3)).fit().summary()
#
# sgt.plot_acf(ARIMA(ts, order=(3, 0, 3)).fit().resid, zero=False)
# plt.rc("figure", figsize=(15, 10))
# plt.ylabel("Coefficient of correlation")
# plt.xlabel("Lags")
# plt.show()
#
# """Great, we see that the first 4 coefficients are now not significant. At this point, as an additional exercise, we could try models with lag 5,6, and 7 as well to further improve performance.
# Next, we are going to look at how to select the value for "d", or the number of integrations required for modelling the data. Remember that integrations are done to introduce stationarity and should be avoided if the data is already stationary. In this case, the adfuller test says that the data is stationary but ACF plot shows many significant correlations. Hence we try d as 1. Let's manually compute 1 degree of integration and check stationarity.
# """
#
# adfuller(ts.diff(1)[1:])
#
# sgt.plot_acf(ts.diff(1)[1:], zero=False)
# plt.rc("figure", figsize=(15, 10))
# plt.ylabel("Coefficient of correlation")
# plt.xlabel("Lags")
# plt.show()
#
# """Cool, the ACF plot has less significant correlations and the adfuller test also indicates that after one integration the data is stationarity.
# For exercise, and a rigorous search for the best model, we could check for models with d=2 as well. However, we prefer simpler models over complex models if the improvements are not significant. Let's fit ARIMA(3,1,1) and evaluate the results.
# """
#
# ARIMA_311 = ARIMA(ts, order=(3, 1, 1)).fit()
# ARIMA_311.summary()
#
# sgt.plot_acf(ARIMA_311.resid, zero=False)
# plt.rc("figure", figsize=(15, 10))
# plt.ylabel("Coefficient of correlation")
# plt.xlabel("Lags")
# plt.show()
#
# """Cool, we see 9 insignificant coefficients indicating that this model is a good choice.
#
# ## ARIMAX (Exogenous factors)
#
# In addition to past observations, sometimes external factors also affect the future value of a time series
#
# $\Delta$P<sub>t</sub> = c + $\beta$X + $\phi$$\Delta$P<sub>t-1</sub> + $\theta$$\epsilon$<sub>t-1</sub> + $\epsilon$<sub>t</sub>
#
# - X can be anything (data should be available for each period).
# - E.g. S&P prices for predicting a particular stock price.
# - $\beta$ is a fitted coefficient.
#
# ## SARIMAX (Seasonality)
# Some time series have a seasonal aspect to them. For example, consider the number of views for a christmas song every month. Every year in December we can expect a spike in the series.
# - SARIMAX model includes a lag term for the last period.
# - Hyper parameters of SARIMAX: (p,d,q)(P,D,Q,s).
# - (p,d,q) is the ARIMA order.
# - 's' signifies how far behind do we observe the seasonal affect; s=1 means no seasonality.
# - In our number of songs example, the value of s will be 12.
# - P, Q specifies how many seasonal AR and MA terms we will have so for s=12, P=2, Q=1, the equation will have y<sub>t-12</sub>,  y<sub>t-24</sub>, and $\epsilon$<sub>t-12</sub>
# - D specifies seasonal integrations.
# - The total number of coefficients for the model will be: P + Q + p + q coeffs.
# - In our current example we don't see any seasonality but let's train a SARIMAX model to understand how it works.
# """
#
# model_sarimax = SARIMAX(
#     ts, exog=wn, order=(3, 1, 1), seasonal_order=(2, 0, 1, 5)
# ).fit()
#
# model_sarimax.summary()
#
# """## Automated
# - In the final section of this notebook, we show the use of auto_arima function of [pmdarima](https://alkaline-ml.com/pmdarima/modules/classes.html) library that automatically finds hyperparameters for a SARIMAX model.
# - However, we need to proceed with caution and do our due diligence before selecting a new model as automated values may choose a complicated model but in real life we may prefer a simpler one.
# - The function does dickey fuller test to find d; and uses one information criteria to select between models (default being "aic").
# - The function does not look at whether all coefficients are significant or not, we have to consider that on our own.
# """
#
# ## Calling auto arima with default settings
# auto_arima_model = auto_arima(ts)
#
# auto_arima_model.summary()
#
# ## Evaluating residuals
# sgt.plot_acf(auto_arima_model.resid(), zero=False)
# plt.rc("figure", figsize=(15, 10))
# plt.ylabel("Coefficient of correlation")
# plt.xlabel("Lags")
# plt.show()
#
# """- Here we see the auto_arima selects an ARIMA model with order 2,1,3. In our manual analysis using statsmodel package, the model with 2,1,3 could not converge. We can make changes to the default parameters to the function to give it more information.
# - An important information criteria is oob which selects model based on the score performance of the model on a validation set. Let's try that.
# """
#
# ## The commented parameters can be uncommented based on the need.
#
# aam = auto_arima(
#     ts,
#     #            exogenous=,
#     #            m=12, SARIMAX s
#     max_order=None,
#     max_p=6,  # Search till p=6
#     max_q=6,  # Search till q=6
#     max_d=2,  # Search till d=2
#     #            max_P= #Search till P=2
#     #            max_Q= #Search till Q=2
#     #            max_D= #Search till D=2
#     maxiter=50,  # Increase if you see no convergence
#     njobs=-1,  # Number of parallel processes
#     #           trend="ct", ##ctt for quadratic; accounts for trend in data
#     information_criterion="oob",  # out of bag aic, aicc, bic, hqic
#     out_of_sample_size=int(len(ts) * 0.2),  ## Validation set of 20% for oob
# )
#
# aam.summary()
#
# sgt.plot_acf(aam.resid(), zero=False)
# plt.rc("figure", figsize=(15, 10))
# plt.ylabel("Coefficient of correlation")
# plt.xlabel("Lags")
# plt.show()
#
# """With updated parameters, especially the information criterion as "oob" we see the function selects an inferior model in terms of AIC and significance of the coefficients. However this model performs well on the validation set. We need to conduct further experiments with a test set to find the generalizability of these models.
#
# # Conclusion
# Awesome! Apologies for a really long notebook, but we have learnt how to understand characteristics of a time series and then how to model it. Next, we are going to look at how we can forecast using these models.
#
# ### Referrences
# - A lot of the content in this notebook has been adapted from this [youtube playlist](https://www.youtube.com/playlist?list=PLtIY5kwXKny91_IbkqcIXuv6t1prQwFhO).
# """